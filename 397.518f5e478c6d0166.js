"use strict";(self.webpackChunktoggl_overhours=self.webpackChunktoggl_overhours||[]).push([[397],{9397:(Fa,Qt,at)=>{at.r(Qt),at.d(Qt,{ByteLengthQueuingStrategy:()=>Ze,CountQueuingStrategy:()=>Xe,ReadableByteStreamController:()=>re,ReadableStream:()=>M,ReadableStreamBYOBReader:()=>me,ReadableStreamBYOBRequest:()=>ce,ReadableStreamDefaultController:()=>ie,ReadableStreamDefaultReader:()=>le,TransformStream:()=>Ke,TransformStreamDefaultController:()=>Ce,WritableStream:()=>pe,WritableStreamDefaultController:()=>oe,WritableStreamDefaultWriter:()=>ye});var un=at(9671);const f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol:e=>`Symbol(${e})`;function ot(){}const Nt=function ln(){return typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:void 0}();function w(e){return"object"==typeof e&&null!==e||"function"==typeof e}const Ut=ot,it=Promise,dn=Promise.prototype.then,fn=Promise.resolve.bind(it),cn=Promise.reject.bind(it);function R(e){return new it(e)}function b(e){return fn(e)}function l(e){return cn(e)}function O(e,t,r){return dn.call(e,t,r)}function T(e,t,r){O(O(e,t,r),void 0,Ut)}function st(e,t){T(e,t)}function ut(e,t){T(e,void 0,t)}function H(e,t,r){return O(e,t,r)}function ue(e){O(e,void 0,Ut)}const Te=(()=>{const e=Nt&&Nt.queueMicrotask;if("function"==typeof e)return e;const t=b(void 0);return r=>O(t,r)})();function ve(e,t,r){if("function"!=typeof e)throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,t,r)}function V(e,t,r){try{return b(ve(e,t,r))}catch(n){return l(n)}}class v{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(t){const r=this._back;let n=r;16383===r._elements.length&&(n={_elements:[],_next:void 0}),r._elements.push(t),n!==r&&(this._back=n,r._next=n),++this._size}shift(){const t=this._front;let r=t;const n=this._cursor;let a=n+1;const o=t._elements,i=o[n];return 16384===a&&(r=t._next,a=0),--this._size,this._cursor=a,t!==r&&(this._front=r),o[n]=void 0,i}forEach(t){let r=this._cursor,n=this._front,a=n._elements;for(;!(r===a.length&&void 0===n._next||r===a.length&&(n=n._next,a=n._elements,r=0,0===a.length));)t(a[r]),++r}peek(){return this._front._elements[this._cursor]}}function Ht(e,t){e._ownerReadableStream=t,t._reader=e,"readable"===t._state?dt(e):"closed"===t._state?function bn(e){dt(e),Gt(e)}(e):Vt(e,t._storedError)}function lt(e,t){return q(e._ownerReadableStream,t)}function z(e){"readable"===e._ownerReadableStream._state?ft(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):function hn(e,t){Vt(e,t)}(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._ownerReadableStream._reader=void 0,e._ownerReadableStream=void 0}function ee(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function dt(e){e._closedPromise=R((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r})}function Vt(e,t){dt(e),ft(e,t)}function ft(e,t){void 0!==e._closedPromise_reject&&(ue(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0)}function Gt(e){void 0!==e._closedPromise_resolve&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0)}const Zt=f("[[AbortSteps]]"),Xt=f("[[ErrorSteps]]"),ct=f("[[CancelSteps]]"),bt=f("[[PullSteps]]"),Kt=Number.isFinite||function(e){return"number"==typeof e&&isFinite(e)},mn=Math.trunc||function(e){return e<0?Math.ceil(e):Math.floor(e)};function j(e,t){if(void 0!==e&&!function _n(e){return"object"==typeof e||"function"==typeof e}(e))throw new TypeError(`${t} is not an object.`)}function W(e,t){if("function"!=typeof e)throw new TypeError(`${t} is not a function.`)}function Jt(e,t){if(!function pn(e){return"object"==typeof e&&null!==e||"function"==typeof e}(e))throw new TypeError(`${t} is not an object.`)}function I(e,t,r){if(void 0===e)throw new TypeError(`Parameter ${t} is required in '${r}'.`)}function ht(e,t,r){if(void 0===e)throw new TypeError(`${t} is required in '${r}'.`)}function mt(e){return Number(e)}function xt(e){return 0===e?0:e}function er(e,t){const n=Number.MAX_SAFE_INTEGER;let a=Number(e);if(a=xt(a),!Kt(a))throw new TypeError(`${t} is not a finite number`);if(a=function yn(e){return xt(mn(e))}(a),a<0||a>n)throw new TypeError(`${t} is outside the accepted range of 0 to ${n}, inclusive`);return Kt(a)&&0!==a?a:0}function _t(e,t){if(!$(e))throw new TypeError(`${t} is not a ReadableStream.`)}function te(e){return new le(e)}function tr(e,t){e._reader._readRequests.push(t)}function pt(e,t,r){const a=e._reader._readRequests.shift();r?a._closeSteps():a._chunkSteps(t)}function We(e){return e._reader._readRequests.length}function rr(e){const t=e._reader;return!(void 0===t||!D(t))}class le{constructor(t){if(I(t,1,"ReadableStreamDefaultReader"),_t(t,"First parameter"),Q(t))throw new TypeError("This stream has already been locked for exclusive reading by another reader");Ht(this,t),this._readRequests=new v}get closed(){return D(this)?this._closedPromise:l(Ee("closed"))}cancel(t){return D(this)?void 0===this._ownerReadableStream?l(ee("cancel")):lt(this,t):l(Ee("cancel"))}read(){if(!D(this))return l(Ee("read"));if(void 0===this._ownerReadableStream)return l(ee("read from"));let t,r;const n=R((o,i)=>{t=o,r=i});return de(this,{_chunkSteps:o=>t({value:o,done:!1}),_closeSteps:()=>t({value:void 0,done:!0}),_errorSteps:o=>r(o)}),n}releaseLock(){if(!D(this))throw Ee("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");z(this)}}}function D(e){return!(!w(e)||!Object.prototype.hasOwnProperty.call(e,"_readRequests"))&&e instanceof le}function de(e,t){const r=e._ownerReadableStream;r._disturbed=!0,"closed"===r._state?t._closeSteps():"errored"===r._state?t._errorSteps(r._storedError):r._readableStreamController[bt](t)}function Ee(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}Object.defineProperties(le.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof f.toStringTag&&Object.defineProperty(le.prototype,f.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0});const nr=Object.getPrototypeOf(Object.getPrototypeOf((0,un.Z)(function*(){})).prototype);class ar{constructor(t,r){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=t,this._preventCancel=r}next(){const t=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?H(this._ongoingPromise,t,t):t(),this._ongoingPromise}return(t){const r=()=>this._returnSteps(t);return this._ongoingPromise?H(this._ongoingPromise,r,r):r()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const t=this._reader;if(void 0===t._ownerReadableStream)return l(ee("iterate"));let r,n;const a=R((i,s)=>{r=i,n=s});return de(t,{_chunkSteps:i=>{this._ongoingPromise=void 0,Te(()=>r({value:i,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,z(t),r({value:void 0,done:!0})},_errorSteps:i=>{this._ongoingPromise=void 0,this._isFinished=!0,z(t),n(i)}}),a}_returnSteps(t){if(this._isFinished)return Promise.resolve({value:t,done:!0});this._isFinished=!0;const r=this._reader;if(void 0===r._ownerReadableStream)return l(ee("finish iterating"));if(!this._preventCancel){const n=lt(r,t);return z(r),H(n,()=>({value:t,done:!0}))}return z(r),b({value:t,done:!0})}}const or={next(){return ir(this)?this._asyncIteratorImpl.next():l(sr("next"))},return(e){return ir(this)?this._asyncIteratorImpl.return(e):l(sr("return"))}};function ir(e){if(!w(e)||!Object.prototype.hasOwnProperty.call(e,"_asyncIteratorImpl"))return!1;try{return e._asyncIteratorImpl instanceof ar}catch{return!1}}function sr(e){return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`)}void 0!==nr&&Object.setPrototypeOf(or,nr);const ur=Number.isNaN||function(e){return e!=e};function fe(e){return e.slice()}function lr(e,t,r,n,a){new Uint8Array(e).set(new Uint8Array(r,n,a),t)}function dr(e,t,r){if(e.slice)return e.slice(t,r);const n=r-t,a=new ArrayBuffer(n);return lr(a,0,e,t,n),a}function fr(e){const t=dr(e.buffer,e.byteOffset,e.byteOffset+e.byteLength);return new Uint8Array(t)}function yt(e){const t=e._queue.shift();return e._queueTotalSize-=t.size,e._queueTotalSize<0&&(e._queueTotalSize=0),t.value}function St(e,t,r){if(!function gn(e){return!("number"!=typeof e||ur(e)||e<0)}(r)||r===1/0)throw new RangeError("Size must be a finite, non-NaN, non-negative number.");e._queue.push({value:t,size:r}),e._queueTotalSize+=r}function F(e){e._queue=new v,e._queueTotalSize=0}class ce{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!gt(this))throw Tt("view");return this._view}respond(t){if(!gt(this))throw Tt("respond");if(I(t,1,"respond"),t=er(t,"First parameter"),void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");Oe(this._associatedReadableByteStreamController,t)}respondWithNewView(t){if(!gt(this))throw Tt("respondWithNewView");if(I(t,1,"respondWithNewView"),!ArrayBuffer.isView(t))throw new TypeError("You can only respond with array buffer views");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");ze(this._associatedReadableByteStreamController,t)}}Object.defineProperties(ce.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),"symbol"==typeof f.toStringTag&&Object.defineProperty(ce.prototype,f.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class re{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!G(this))throw he("byobRequest");return Pt(this)}get desiredSize(){if(!G(this))throw he("desiredSize");return Sr(this)}close(){if(!G(this))throw he("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const t=this._controlledReadableByteStream._state;if("readable"!==t)throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be closed`);be(this)}enqueue(t){if(!G(this))throw he("enqueue");if(I(t,1,"enqueue"),!ArrayBuffer.isView(t))throw new TypeError("chunk must be an array buffer view");if(0===t.byteLength)throw new TypeError("chunk must have non-zero byteLength");if(0===t.buffer.byteLength)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const r=this._controlledReadableByteStream._state;if("readable"!==r)throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);Be(this,t)}error(t){if(!G(this))throw he("error");E(this,t)}[ct](t){cr(this),F(this);const r=this._cancelAlgorithm(t);return ke(this),r}[bt](t){const r=this._controlledReadableByteStream;if(this._queueTotalSize>0){const a=this._queue.shift();this._queueTotalSize-=a.byteLength,_r(this);const o=new Uint8Array(a.buffer,a.byteOffset,a.byteLength);return void t._chunkSteps(o)}const n=this._autoAllocateChunkSize;if(void 0!==n){let a;try{a=new ArrayBuffer(n)}catch(i){return void t._errorSteps(i)}const o={buffer:a,bufferByteLength:n,byteOffset:0,byteLength:n,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(o)}tr(r,t),Z(this)}}function G(e){return!(!w(e)||!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream"))&&e instanceof re}function gt(e){return!(!w(e)||!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController"))&&e instanceof ce}function Z(e){(function Tn(e){const t=e._controlledReadableByteStream;return!("readable"!==t._state||e._closeRequested||!e._started||!(rr(t)&&We(t)>0||vt(t)&&Cr(t)>0||Sr(e)>0))})(e)&&(e._pulling?e._pullAgain=!0:(e._pulling=!0,T(e._pullAlgorithm(),()=>{e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,Z(e))},n=>{E(e,n)})))}function cr(e){wt(e),e._pendingPullIntos=new v}function Rt(e,t){let r=!1;"closed"===e._state&&(r=!0);const n=br(t);"default"===t.readerType?pt(e,n,r):function En(e,t,r){const a=e._reader._readIntoRequests.shift();r?a._closeSteps(t):a._chunkSteps(t)}(e,n,r)}function br(e){return new e.viewConstructor(e.buffer,e.byteOffset,e.bytesFilled/e.elementSize)}function Ae(e,t,r,n){e._queue.push({buffer:t,byteOffset:r,byteLength:n}),e._queueTotalSize+=n}function hr(e,t){const r=t.elementSize,n=t.bytesFilled-t.bytesFilled%r,a=Math.min(e._queueTotalSize,t.byteLength-t.bytesFilled),o=t.bytesFilled+a,i=o-o%r;let s=a,u=!1;i>n&&(s=i-t.bytesFilled,u=!0);const c=e._queue;for(;s>0;){const p=c.peek(),m=Math.min(s,p.byteLength);lr(t.buffer,t.byteOffset+t.bytesFilled,p.buffer,p.byteOffset,m),p.byteLength===m?c.shift():(p.byteOffset+=m,p.byteLength-=m),e._queueTotalSize-=m,mr(0,m,t),s-=m}return u}function mr(e,t,r){r.bytesFilled+=t}function _r(e){0===e._queueTotalSize&&e._closeRequested?(ke(e),we(e._controlledReadableByteStream)):Z(e)}function wt(e){null!==e._byobRequest&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=null,e._byobRequest=null)}function pr(e){for(;e._pendingPullIntos.length>0;){if(0===e._queueTotalSize)return;const t=e._pendingPullIntos.peek();hr(e,t)&&(Ct(e),Rt(e._controlledReadableByteStream,t))}}function yr(e,t){const r=e._pendingPullIntos.peek();wt(e),"closed"===e._controlledReadableByteStream._state?function Cn(e,t){const r=e._controlledReadableByteStream;if(vt(r))for(;Cr(r)>0;)Rt(r,Ct(e))}(e):function Pn(e,t,r){if(mr(0,t,r),r.bytesFilled<r.elementSize)return;Ct(e);const n=r.bytesFilled%r.elementSize;if(n>0){const a=r.byteOffset+r.bytesFilled,o=dr(r.buffer,a-n,a);Ae(e,o,0,o.byteLength)}r.bytesFilled-=n,Rt(e._controlledReadableByteStream,r),pr(e)}(e,t,r),Z(e)}function Ct(e){return e._pendingPullIntos.shift()}function ke(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0}function be(e){const t=e._controlledReadableByteStream;if(!e._closeRequested&&"readable"===t._state){if(e._queueTotalSize>0)return void(e._closeRequested=!0);if(e._pendingPullIntos.length>0&&e._pendingPullIntos.peek().bytesFilled>0){const n=new TypeError("Insufficient bytes to fill elements in the given buffer");throw E(e,n),n}ke(e),we(t)}}function Be(e,t){const r=e._controlledReadableByteStream;if(e._closeRequested||"readable"!==r._state)return;const a=t.byteOffset,o=t.byteLength,i=t.buffer;if(e._pendingPullIntos.length>0){const s=e._pendingPullIntos.peek();s.buffer=s.buffer}wt(e),rr(r)?0===We(r)?Ae(e,i,a,o):pt(r,new Uint8Array(i,a,o),!1):vt(r)?(Ae(e,i,a,o),pr(e)):Ae(e,i,a,o),Z(e)}function E(e,t){const r=e._controlledReadableByteStream;"readable"===r._state&&(cr(e),F(e),ke(e),Vr(r,t))}function Pt(e){if(null===e._byobRequest&&e._pendingPullIntos.length>0){const t=e._pendingPullIntos.peek(),r=new Uint8Array(t.buffer,t.byteOffset+t.bytesFilled,t.byteLength-t.bytesFilled),n=Object.create(ce.prototype);(function Wn(e,t,r){e._associatedReadableByteStreamController=t,e._view=r})(n,e,r),e._byobRequest=n}return e._byobRequest}function Sr(e){const t=e._controlledReadableByteStream._state;return"errored"===t?null:"closed"===t?0:e._strategyHWM-e._queueTotalSize}function Oe(e,t){const r=e._pendingPullIntos.peek();if("closed"===e._controlledReadableByteStream._state){if(0!==t)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(0===t)throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(r.bytesFilled+t>r.byteLength)throw new RangeError("bytesWritten out of range")}r.buffer=r.buffer,yr(e,t)}function ze(e,t){const r=e._pendingPullIntos.peek();if("closed"===e._controlledReadableByteStream._state){if(0!==t.byteLength)throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}else if(0===t.byteLength)throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");if(r.byteOffset+r.bytesFilled!==t.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(r.bufferByteLength!==t.buffer.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");if(r.bytesFilled+t.byteLength>r.byteLength)throw new RangeError("The region specified by view is larger than byobRequest");r.buffer=t.buffer,yr(e,t.byteLength)}function gr(e,t,r,n,a,o,i){t._controlledReadableByteStream=e,t._pullAgain=!1,t._pulling=!1,t._byobRequest=null,t._queue=t._queueTotalSize=void 0,F(t),t._closeRequested=!1,t._started=!1,t._strategyHWM=o,t._pullAlgorithm=n,t._cancelAlgorithm=a,t._autoAllocateChunkSize=i,t._pendingPullIntos=new v,e._readableStreamController=t,T(b(r()),()=>{t._started=!0,Z(t)},u=>{E(t,u)})}function Tt(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function he(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}function Rr(e){return new me(e)}function wr(e,t){e._reader._readIntoRequests.push(t)}function Cr(e){return e._reader._readIntoRequests.length}function vt(e){const t=e._reader;return!(void 0===t||!X(t))}Object.defineProperties(re.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof f.toStringTag&&Object.defineProperty(re.prototype,f.toStringTag,{value:"ReadableByteStreamController",configurable:!0});class me{constructor(t){if(I(t,1,"ReadableStreamBYOBReader"),_t(t,"First parameter"),Q(t))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!G(t._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");Ht(this,t),this._readIntoRequests=new v}get closed(){return X(this)?this._closedPromise:l(je("closed"))}cancel(t){return X(this)?void 0===this._ownerReadableStream?l(ee("cancel")):lt(this,t):l(je("cancel"))}read(t){if(!X(this))return l(je("read"));if(!ArrayBuffer.isView(t))return l(new TypeError("view must be an array buffer view"));if(0===t.byteLength)return l(new TypeError("view must have non-zero byteLength"));if(0===t.buffer.byteLength)return l(new TypeError("view's buffer must have non-zero byteLength"));if(void 0===this._ownerReadableStream)return l(ee("read from"));let r,n;const a=R((i,s)=>{r=i,n=s});return Pr(this,t,{_chunkSteps:i=>r({value:i,done:!1}),_closeSteps:i=>r({value:i,done:!0}),_errorSteps:i=>n(i)}),a}releaseLock(){if(!X(this))throw je("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");z(this)}}}function X(e){return!(!w(e)||!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests"))&&e instanceof me}function Pr(e,t,r){const n=e._ownerReadableStream;n._disturbed=!0,"errored"===n._state?r._errorSteps(n._storedError):function wn(e,t,r){const n=e._controlledReadableByteStream;let a=1;t.constructor!==DataView&&(a=t.constructor.BYTES_PER_ELEMENT);const o=t.constructor,i=t.buffer,s={buffer:i,bufferByteLength:i.byteLength,byteOffset:t.byteOffset,byteLength:t.byteLength,bytesFilled:0,elementSize:a,viewConstructor:o,readerType:"byob"};if(e._pendingPullIntos.length>0)return e._pendingPullIntos.push(s),void wr(n,r);if("closed"!==n._state){if(e._queueTotalSize>0){if(hr(e,s)){const u=br(s);return _r(e),void r._chunkSteps(u)}if(e._closeRequested){const u=new TypeError("Insufficient bytes to fill elements in the given buffer");return E(e,u),void r._errorSteps(u)}}e._pendingPullIntos.push(s),wr(n,r),Z(e)}else{const u=new o(s.buffer,s.byteOffset,0);r._closeSteps(u)}}(n._readableStreamController,t,r)}function je(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function _e(e,t){const{highWaterMark:r}=e;if(void 0===r)return t;if(ur(r)||r<0)throw new RangeError("Invalid highWaterMark");return r}function Ie(e){const{size:t}=e;return t||(()=>1)}function De(e,t){j(e,t);const r=e?.highWaterMark,n=e?.size;return{highWaterMark:void 0===r?void 0:mt(r),size:void 0===n?void 0:qn(n,`${t} has member 'size' that`)}}function qn(e,t){return W(e,t),r=>mt(e(r))}function kn(e,t,r){return W(e,r),n=>V(e,t,[n])}function Bn(e,t,r){return W(e,r),()=>V(e,t,[])}function On(e,t,r){return W(e,r),n=>ve(e,t,[n])}function zn(e,t,r){return W(e,r),(n,a)=>V(e,t,[n,a])}function Tr(e,t){if(!ne(e))throw new TypeError(`${t} is not a WritableStream.`)}Object.defineProperties(me.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof f.toStringTag&&Object.defineProperty(me.prototype,f.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});const In="function"==typeof AbortController;class pe{constructor(t={},r={}){void 0===t?t=null:Jt(t,"First parameter");const n=De(r,"Second parameter"),a=function An(e,t){j(e,t);const r=e?.abort,n=e?.close,a=e?.start,o=e?.type,i=e?.write;return{abort:void 0===r?void 0:kn(r,e,`${t} has member 'abort' that`),close:void 0===n?void 0:Bn(n,e,`${t} has member 'close' that`),start:void 0===a?void 0:On(a,e,`${t} has member 'start' that`),write:void 0===i?void 0:zn(i,e,`${t} has member 'write' that`),type:o}}(t,"First parameter");if(Wr(this),void 0!==a.type)throw new RangeError("Invalid type is specified");const i=Ie(n);!function Kn(e,t,r,n){const a=Object.create(oe.prototype);let o=()=>{},i=()=>b(void 0),s=()=>b(void 0),u=()=>b(void 0);void 0!==t.start&&(o=()=>t.start(a)),void 0!==t.write&&(i=c=>t.write(c,a)),void 0!==t.close&&(s=()=>t.close()),void 0!==t.abort&&(u=c=>t.abort(c)),zr(e,a,o,i,s,u,r,n)}(this,a,_e(n,1),i)}get locked(){if(!ne(this))throw Qe("locked");return ae(this)}abort(t){return ne(this)?ae(this)?l(new TypeError("Cannot abort a stream that already has a writer")):Fe(this,t):l(Qe("abort"))}close(){return ne(this)?ae(this)?l(new TypeError("Cannot close a stream that already has a writer")):k(this)?l(new TypeError("Cannot close an already-closing stream")):Er(this):l(Qe("close"))}getWriter(){if(!ne(this))throw Qe("getWriter");return vr(this)}}function vr(e){return new ye(e)}function Wr(e){e._state="writable",e._storedError=void 0,e._writer=void 0,e._writableStreamController=void 0,e._writeRequests=new v,e._inFlightWriteRequest=void 0,e._closeRequest=void 0,e._inFlightCloseRequest=void 0,e._pendingAbortRequest=void 0,e._backpressure=!1}function ne(e){return!(!w(e)||!Object.prototype.hasOwnProperty.call(e,"_writableStreamController"))&&e instanceof pe}function ae(e){return void 0!==e._writer}function Fe(e,t){var r;if("closed"===e._state||"errored"===e._state)return b(void 0);e._writableStreamController._abortReason=t,null===(r=e._writableStreamController._abortController)||void 0===r||r.abort();const n=e._state;if("closed"===n||"errored"===n)return b(void 0);if(void 0!==e._pendingAbortRequest)return e._pendingAbortRequest._promise;let a=!1;"erroring"===n&&(a=!0,t=void 0);const o=R((i,s)=>{e._pendingAbortRequest={_promise:void 0,_resolve:i,_reject:s,_reason:t,_wasAlreadyErroring:a}});return e._pendingAbortRequest._promise=o,a||Et(e,t),o}function Er(e){const t=e._state;if("closed"===t||"errored"===t)return l(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const r=R((a,o)=>{e._closeRequest={_resolve:a,_reject:o}}),n=e._writer;return void 0!==n&&e._backpressure&&"writable"===t&&Dt(n),function Jn(e){St(e,Or,0),$e(e)}(e._writableStreamController),r}function Wt(e,t){"writable"!==e._state?qt(e):Et(e,t)}function Et(e,t){const r=e._writableStreamController;e._state="erroring",e._storedError=t;const n=e._writer;void 0!==n&&Ar(n,t),!function Un(e){return!(void 0===e._inFlightWriteRequest&&void 0===e._inFlightCloseRequest)}(e)&&r._started&&qt(e)}function qt(e){e._state="errored",e._writableStreamController[Xt]();const t=e._storedError;if(e._writeRequests.forEach(a=>{a._reject(t)}),e._writeRequests=new v,void 0===e._pendingAbortRequest)return void Le(e);const r=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,r._wasAlreadyErroring)return r._reject(t),void Le(e);T(e._writableStreamController[Zt](r._reason),()=>{r._resolve(),Le(e)},a=>{r._reject(a),Le(e)})}function k(e){return!(void 0===e._closeRequest&&void 0===e._inFlightCloseRequest)}function Le(e){void 0!==e._closeRequest&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const t=e._writer;void 0!==t&&jt(t,e._storedError)}function At(e,t){const r=e._writer;void 0!==r&&t!==e._backpressure&&(t?function oa(e){Ue(e)}(r):Dt(r)),e._backpressure=t}Object.defineProperties(pe.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof f.toStringTag&&Object.defineProperty(pe.prototype,f.toStringTag,{value:"WritableStream",configurable:!0});class ye{constructor(t){if(I(t,1,"WritableStreamDefaultWriter"),Tr(t,"First parameter"),ae(t))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=t,t._writer=this;const r=t._state;if("writable"===r)!k(t)&&t._backpressure?Ue(this):Lr(this),Ne(this);else if("erroring"===r)It(this,t._storedError),Ne(this);else if("closed"===r)Lr(this),function na(e){Ne(e),Fr(e)}(this);else{const n=t._storedError;It(this,n),Dr(this,n)}}get closed(){return K(this)?this._closedPromise:l(J("closed"))}get desiredSize(){if(!K(this))throw J("desiredSize");if(void 0===this._ownerWritableStream)throw Se("desiredSize");return function Xn(e){const t=e._ownerWritableStream,r=t._state;return"errored"===r||"erroring"===r?null:"closed"===r?0:jr(t._writableStreamController)}(this)}get ready(){return K(this)?this._readyPromise:l(J("ready"))}abort(t){return K(this)?void 0===this._ownerWritableStream?l(Se("abort")):function Vn(e,t){return Fe(e._ownerWritableStream,t)}(this,t):l(J("abort"))}close(){if(!K(this))return l(J("close"));const t=this._ownerWritableStream;return void 0===t?l(Se("close")):k(t)?l(new TypeError("Cannot close an already-closing stream")):qr(this)}releaseLock(){if(!K(this))throw J("releaseLock");void 0!==this._ownerWritableStream&&kr(this)}write(t){return K(this)?void 0===this._ownerWritableStream?l(Se("write to")):Br(this,t):l(J("write"))}}function K(e){return!(!w(e)||!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream"))&&e instanceof ye}function qr(e){return Er(e._ownerWritableStream)}function Ar(e,t){"pending"===e._readyPromiseState?Mr(e,t):function ia(e,t){It(e,t)}(e,t)}function kr(e){const t=e._ownerWritableStream,r=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");Ar(e,r),function Zn(e,t){"pending"===e._closedPromiseState?jt(e,t):function aa(e,t){Dr(e,t)}(e,t)}(e,r),t._writer=void 0,e._ownerWritableStream=void 0}function Br(e,t){const r=e._ownerWritableStream,n=r._writableStreamController,a=function xn(e,t){try{return e._strategySizeAlgorithm(t)}catch(r){return Bt(e,r),1}}(n,t);if(r!==e._ownerWritableStream)return l(Se("write to"));const o=r._state;if("errored"===o)return l(r._storedError);if(k(r)||"closed"===o)return l(new TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===o)return l(r._storedError);const i=function Ln(e){return R((r,n)=>{e._writeRequests.push({_resolve:r,_reject:n})})}(r);return function ea(e,t,r){try{St(e,t,r)}catch(a){return void Bt(e,a)}const n=e._controlledWritableStream;k(n)||"writable"!==n._state||At(n,Ot(e)),$e(e)}(n,t,a),i}Object.defineProperties(ye.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),"symbol"==typeof f.toStringTag&&Object.defineProperty(ye.prototype,f.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});const Or={};class oe{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!kt(this))throw zt("abortReason");return this._abortReason}get signal(){if(!kt(this))throw zt("signal");if(void 0===this._abortController)throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error(t){if(!kt(this))throw zt("error");"writable"===this._controlledWritableStream._state&&Ir(this,t)}[Zt](t){const r=this._abortAlgorithm(t);return Me(this),r}[Xt](){F(this)}}function kt(e){return!(!w(e)||!Object.prototype.hasOwnProperty.call(e,"_controlledWritableStream"))&&e instanceof oe}function zr(e,t,r,n,a,o,i,s){t._controlledWritableStream=e,e._writableStreamController=t,t._queue=void 0,t._queueTotalSize=void 0,F(t),t._abortReason=void 0,t._abortController=function Dn(){if(In)return new AbortController}(),t._started=!1,t._strategySizeAlgorithm=s,t._strategyHWM=i,t._writeAlgorithm=n,t._closeAlgorithm=a,t._abortAlgorithm=o;const u=Ot(t);At(e,u),T(b(r()),()=>{t._started=!0,$e(t)},m=>{t._started=!0,Wt(e,m)})}function Me(e){e._writeAlgorithm=void 0,e._closeAlgorithm=void 0,e._abortAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function jr(e){return e._strategyHWM-e._queueTotalSize}function $e(e){const t=e._controlledWritableStream;if(!e._started||void 0!==t._inFlightWriteRequest)return;if("erroring"===t._state)return void qt(t);if(0===e._queue.length)return;const n=function Rn(e){return e._queue.peek().value}(e);n===Or?function ta(e){const t=e._controlledWritableStream;(function Yn(e){e._inFlightCloseRequest=e._closeRequest,e._closeRequest=void 0})(t),yt(e);const r=e._closeAlgorithm();Me(e),T(r,()=>{!function Qn(e){e._inFlightCloseRequest._resolve(void 0),e._inFlightCloseRequest=void 0,"erroring"===e._state&&(e._storedError=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._resolve(),e._pendingAbortRequest=void 0)),e._state="closed";const r=e._writer;void 0!==r&&Fr(r)}(t)},n=>{!function Nn(e,t){e._inFlightCloseRequest._reject(t),e._inFlightCloseRequest=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._reject(t),e._pendingAbortRequest=void 0),Wt(e,t)}(t,n)})}(e):function ra(e,t){const r=e._controlledWritableStream;!function Hn(e){e._inFlightWriteRequest=e._writeRequests.shift()}(r),T(e._writeAlgorithm(t),()=>{!function Mn(e){e._inFlightWriteRequest._resolve(void 0),e._inFlightWriteRequest=void 0}(r);const a=r._state;if(yt(e),!k(r)&&"writable"===a){const o=Ot(e);At(r,o)}$e(e)},a=>{"writable"===r._state&&Me(e),function $n(e,t){e._inFlightWriteRequest._reject(t),e._inFlightWriteRequest=void 0,Wt(e,t)}(r,a)})}(e,n)}function Bt(e,t){"writable"===e._controlledWritableStream._state&&Ir(e,t)}function Ot(e){return jr(e)<=0}function Ir(e,t){const r=e._controlledWritableStream;Me(e),Et(r,t)}function Qe(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function zt(e){return new TypeError(`WritableStreamDefaultController.prototype.${e} can only be used on a WritableStreamDefaultController`)}function J(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function Se(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function Ne(e){e._closedPromise=R((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r,e._closedPromiseState="pending"})}function Dr(e,t){Ne(e),jt(e,t)}function jt(e,t){void 0!==e._closedPromise_reject&&(ue(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected")}function Fr(e){void 0!==e._closedPromise_resolve&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved")}function Ue(e){e._readyPromise=R((t,r)=>{e._readyPromise_resolve=t,e._readyPromise_reject=r}),e._readyPromiseState="pending"}function It(e,t){Ue(e),Mr(e,t)}function Lr(e){Ue(e),Dt(e)}function Mr(e,t){void 0!==e._readyPromise_reject&&(ue(e._readyPromise),e._readyPromise_reject(t),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected")}function Dt(e){void 0!==e._readyPromise_resolve&&(e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled")}Object.defineProperties(oe.prototype,{error:{enumerable:!0}}),"symbol"==typeof f.toStringTag&&Object.defineProperty(oe.prototype,f.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});const $r=typeof DOMException<"u"?DOMException:void 0,la=function sa(e){if("function"!=typeof e&&"object"!=typeof e)return!1;try{return new e,!0}catch{return!1}}($r)?$r:function ua(){const e=function(r,n){this.message=r||"",this.name=n||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)};return e.prototype=Object.create(Error.prototype),Object.defineProperty(e.prototype,"constructor",{value:e,writable:!0,configurable:!0}),e}();function Qr(e,t,r,n,a,o){const i=te(e),s=vr(t);e._disturbed=!0;let u=!1,c=b(void 0);return R((p,m)=>{let S;if(void 0!==o){if(S=()=>{const d=new la("Aborted","AbortError"),h=[];n||h.push(()=>"writable"===t._state?Fe(t,d):b(void 0)),a||h.push(()=>"readable"===e._state?q(e,d):b(void 0)),P(()=>Promise.all(h.map(g=>g())),!0,d)},o.aborted)return void S();o.addEventListener("abort",S)}if(C(e,i._closedPromise,d=>{n?_(!0,d):P(()=>Fe(t,d),!0,d)}),C(t,s._closedPromise,d=>{a?_(!0,d):P(()=>q(e,d),!0,d)}),function B(d,h,g){"closed"===d._state?g():st(h,g)}(e,i._closedPromise,()=>{r?_():P(()=>function Gn(e){const t=e._ownerWritableStream,r=t._state;return k(t)||"closed"===r?b(void 0):"errored"===r?l(t._storedError):qr(e)}(s))}),k(t)||"closed"===t._state){const d=new TypeError("the destination writable stream closed before all data could be piped to it");a?_(!0,d):P(()=>q(e,d),!0,d)}function U(){const d=c;return O(c,()=>d!==c?U():void 0)}function C(d,h,g){"errored"===d._state?g(d._storedError):ut(h,g)}function P(d,h,g){function A(){T(d(),()=>y(h,g),Y=>y(!0,Y))}u||(u=!0,"writable"!==t._state||k(t)?A():st(U(),A))}function _(d,h){u||(u=!0,"writable"!==t._state||k(t)?y(d,h):st(U(),()=>y(d,h)))}function y(d,h){kr(s),z(i),void 0!==o&&o.removeEventListener("abort",S),d?m(h):p(void 0)}ue(function N(){return R((d,h)=>{!function g(A){A?d():O(function Pe(){return u?b(!0):O(s._readyPromise,()=>R((d,h)=>{de(i,{_chunkSteps:g=>{c=O(Br(s,g),void 0,ot),d(!1)},_closeSteps:()=>d(!0),_errorSteps:h})}))}(),g,h)}(!1)})}())})}class ie{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!Ye(this))throw Ge("desiredSize");return Ft(this)}close(){if(!Ye(this))throw Ge("close");if(!se(this))throw new TypeError("The stream is not in a state that permits close");Re(this)}enqueue(t){if(!Ye(this))throw Ge("enqueue");if(!se(this))throw new TypeError("The stream is not in a state that permits enqueue");return Ve(this,t)}error(t){if(!Ye(this))throw Ge("error");L(this,t)}[ct](t){F(this);const r=this._cancelAlgorithm(t);return He(this),r}[bt](t){const r=this._controlledReadableStream;if(this._queue.length>0){const n=yt(this);this._closeRequested&&0===this._queue.length?(He(this),we(r)):ge(this),t._chunkSteps(n)}else tr(r,t),ge(this)}}function Ye(e){return!(!w(e)||!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream"))&&e instanceof ie}function ge(e){Nr(e)&&(e._pulling?e._pullAgain=!0:(e._pulling=!0,T(e._pullAlgorithm(),()=>{e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,ge(e))},n=>{L(e,n)})))}function Nr(e){const t=e._controlledReadableStream;return!(!se(e)||!e._started||!(Q(t)&&We(t)>0||Ft(e)>0))}function He(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function Re(e){if(!se(e))return;const t=e._controlledReadableStream;e._closeRequested=!0,0===e._queue.length&&(He(e),we(t))}function Ve(e,t){if(!se(e))return;const r=e._controlledReadableStream;if(Q(r)&&We(r)>0)pt(r,t,!1);else{let n;try{n=e._strategySizeAlgorithm(t)}catch(a){throw L(e,a),a}try{St(e,t,n)}catch(a){throw L(e,a),a}}ge(e)}function L(e,t){const r=e._controlledReadableStream;"readable"===r._state&&(F(e),He(e),Vr(r,t))}function Ft(e){const t=e._controlledReadableStream._state;return"errored"===t?null:"closed"===t?0:e._strategyHWM-e._queueTotalSize}function se(e){return!e._closeRequested&&"readable"===e._controlledReadableStream._state}function Ur(e,t,r,n,a,o,i){t._controlledReadableStream=e,t._queue=void 0,t._queueTotalSize=void 0,F(t),t._started=!1,t._closeRequested=!1,t._pullAgain=!1,t._pulling=!1,t._strategySizeAlgorithm=i,t._strategyHWM=o,t._pullAlgorithm=n,t._cancelAlgorithm=a,e._readableStreamController=t,T(b(r()),()=>{t._started=!0,ge(t)},u=>{L(t,u)})}function Ge(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function _a(e,t,r){return W(e,r),n=>V(e,t,[n])}function pa(e,t,r){return W(e,r),n=>V(e,t,[n])}function ya(e,t,r){return W(e,r),n=>ve(e,t,[n])}function Sa(e,t){if("bytes"!=(e=`${e}`))throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamType`);return e}function Ra(e,t){if("byob"!=(e=`${e}`))throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`);return e}function Yr(e,t){j(e,t);const r=e?.preventAbort,n=e?.preventCancel,a=e?.preventClose,o=e?.signal;return void 0!==o&&function Ca(e,t){if(!function jn(e){if("object"!=typeof e||null===e)return!1;try{return"boolean"==typeof e.aborted}catch{return!1}}(e))throw new TypeError(`${t} is not an AbortSignal.`)}(o,`${t} has member 'signal' that`),{preventAbort:Boolean(r),preventCancel:Boolean(n),preventClose:Boolean(a),signal:o}}Object.defineProperties(ie.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof f.toStringTag&&Object.defineProperty(ie.prototype,f.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});class M{constructor(t={},r={}){void 0===t?t=null:Jt(t,"First parameter");const n=De(r,"Second parameter"),a=function ma(e,t){j(e,t);const r=e,n=r?.autoAllocateChunkSize,a=r?.cancel,o=r?.pull,i=r?.start,s=r?.type;return{autoAllocateChunkSize:void 0===n?void 0:er(n,`${t} has member 'autoAllocateChunkSize' that`),cancel:void 0===a?void 0:_a(a,r,`${t} has member 'cancel' that`),pull:void 0===o?void 0:pa(o,r,`${t} has member 'pull' that`),start:void 0===i?void 0:ya(i,r,`${t} has member 'start' that`),type:void 0===s?void 0:Sa(s,`${t} has member 'type' that`)}}(t,"First parameter");if(Mt(this),"bytes"===a.type){if(void 0!==n.size)throw new RangeError("The strategy for a byte stream cannot have a size function");!function vn(e,t,r){const n=Object.create(re.prototype);let a=()=>{},o=()=>b(void 0),i=()=>b(void 0);void 0!==t.start&&(a=()=>t.start(n)),void 0!==t.pull&&(o=()=>t.pull(n)),void 0!==t.cancel&&(i=u=>t.cancel(u));const s=t.autoAllocateChunkSize;if(0===s)throw new TypeError("autoAllocateChunkSize must be greater than 0");gr(e,n,a,o,i,r,s)}(this,a,_e(n,0))}else{const o=Ie(n);!function fa(e,t,r,n){const a=Object.create(ie.prototype);let o=()=>{},i=()=>b(void 0),s=()=>b(void 0);void 0!==t.start&&(o=()=>t.start(a)),void 0!==t.pull&&(i=()=>t.pull(a)),void 0!==t.cancel&&(s=u=>t.cancel(u)),Ur(e,a,o,i,s,r,n)}(this,a,_e(n,1),o)}}get locked(){if(!$(this))throw x("locked");return Q(this)}cancel(t){return $(this)?Q(this)?l(new TypeError("Cannot cancel a stream that already has a reader")):q(this,t):l(x("cancel"))}getReader(t){if(!$(this))throw x("getReader");return void 0===function ga(e,t){j(e,t);const r=e?.mode;return{mode:void 0===r?void 0:Ra(r,`${t} has member 'mode' that`)}}(t,"First parameter").mode?te(this):Rr(this)}pipeThrough(t,r={}){if(!$(this))throw x("pipeThrough");I(t,1,"pipeThrough");const n=function Pa(e,t){j(e,t);const r=e?.readable;ht(r,"readable","ReadableWritablePair"),_t(r,`${t} has member 'readable' that`);const n=e?.writable;return ht(n,"writable","ReadableWritablePair"),Tr(n,`${t} has member 'writable' that`),{readable:r,writable:n}}(t,"First parameter"),a=Yr(r,"Second parameter");if(Q(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(ae(n.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return ue(Qr(this,n.writable,a.preventClose,a.preventAbort,a.preventCancel,a.signal)),n.readable}pipeTo(t,r={}){if(!$(this))return l(x("pipeTo"));if(void 0===t)return l("Parameter 1 is required in 'pipeTo'.");if(!ne(t))return l(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let n;try{n=Yr(r,"Second parameter")}catch(a){return l(a)}return Q(this)?l(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):ae(t)?l(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):Qr(this,t,n.preventClose,n.preventAbort,n.preventCancel,n.signal)}tee(){if(!$(this))throw x("tee");return fe(function ca(e,t){return G(e._readableStreamController)?function ha(e){let o,i,s,u,c,t=te(e),r=!1,n=!1,a=!1;const p=R(_=>{c=_});function m(_){ut(_._closedPromise,y=>{_===t&&(E(s._readableStreamController,y),E(u._readableStreamController,y),(!n||!a)&&c(void 0))})}function S(){X(t)&&(z(t),t=te(e),m(t)),de(t,{_chunkSteps:y=>{Te(()=>{r=!1;const d=y;let h=y;if(!n&&!a)try{h=fr(y)}catch(g){return E(s._readableStreamController,g),E(u._readableStreamController,g),void c(q(e,g))}n||Be(s._readableStreamController,d),a||Be(u._readableStreamController,h)})},_closeSteps:()=>{r=!1,n||be(s._readableStreamController),a||be(u._readableStreamController),s._readableStreamController._pendingPullIntos.length>0&&Oe(s._readableStreamController,0),u._readableStreamController._pendingPullIntos.length>0&&Oe(u._readableStreamController,0),(!n||!a)&&c(void 0)},_errorSteps:()=>{r=!1}})}function N(_,y){D(t)&&(z(t),t=Rr(e),m(t));const d=y?u:s,h=y?s:u;Pr(t,_,{_chunkSteps:A=>{Te(()=>{r=!1;const Y=y?a:n;if(y?n:a)Y||ze(d._readableStreamController,A);else{let sn;try{sn=fr(A)}catch($t){return E(d._readableStreamController,$t),E(h._readableStreamController,$t),void c(q(e,$t))}Y||ze(d._readableStreamController,A),Be(h._readableStreamController,sn)}})},_closeSteps:A=>{r=!1;const Y=y?a:n,nt=y?n:a;Y||be(d._readableStreamController),nt||be(h._readableStreamController),void 0!==A&&(Y||ze(d._readableStreamController,A),!nt&&h._readableStreamController._pendingPullIntos.length>0&&Oe(h._readableStreamController,0)),(!Y||!nt)&&c(void 0)},_errorSteps:()=>{r=!1}})}function P(){}return s=Hr(P,function Pe(){if(r)return b(void 0);r=!0;const _=Pt(s._readableStreamController);return null===_?S():N(_._view,!1),b(void 0)},function C(_){if(n=!0,o=_,a){const y=fe([o,i]),d=q(e,y);c(d)}return p}),u=Hr(P,function U(){if(r)return b(void 0);r=!0;const _=Pt(u._readableStreamController);return null===_?S():N(_._view,!0),b(void 0)},function B(_){if(a=!0,i=_,n){const y=fe([o,i]),d=q(e,y);c(d)}return p}),m(t),[s,u]}(e):function ba(e,t){const r=te(e);let i,s,u,c,p,n=!1,a=!1,o=!1;const m=R(C=>{p=C});function S(){return n||(n=!0,de(r,{_chunkSteps:B=>{Te(()=>{n=!1;const _=B;a||Ve(u._readableStreamController,B),o||Ve(c._readableStreamController,_)})},_closeSteps:()=>{n=!1,a||Re(u._readableStreamController),o||Re(c._readableStreamController),(!a||!o)&&p(void 0)},_errorSteps:()=>{n=!1}})),b(void 0)}function U(){}return u=Lt(U,S,function N(C){if(a=!0,i=C,o){const B=fe([i,s]),P=q(e,B);p(P)}return m}),c=Lt(U,S,function Pe(C){if(o=!0,s=C,a){const B=fe([i,s]),P=q(e,B);p(P)}return m}),ut(r._closedPromise,C=>{L(u._readableStreamController,C),L(c._readableStreamController,C),(!a||!o)&&p(void 0)}),[u,c]}(e)}(this))}values(t){if(!$(this))throw x("values");const r=function wa(e,t){j(e,t);const r=e?.preventCancel;return{preventCancel:Boolean(r)}}(t,"First parameter");return function Sn(e,t){const r=te(e),n=new ar(r,t),a=Object.create(or);return a._asyncIteratorImpl=n,a}(this,r.preventCancel)}}function Lt(e,t,r,n=1,a=(()=>1)){const o=Object.create(M.prototype);return Mt(o),Ur(o,Object.create(ie.prototype),e,t,r,n,a),o}function Hr(e,t,r){const n=Object.create(M.prototype);return Mt(n),gr(n,Object.create(re.prototype),e,t,r,0,void 0),n}function Mt(e){e._state="readable",e._reader=void 0,e._storedError=void 0,e._disturbed=!1}function $(e){return!(!w(e)||!Object.prototype.hasOwnProperty.call(e,"_readableStreamController"))&&e instanceof M}function Q(e){return void 0!==e._reader}function q(e,t){if(e._disturbed=!0,"closed"===e._state)return b(void 0);if("errored"===e._state)return l(e._storedError);we(e);const r=e._reader;return void 0!==r&&X(r)&&(r._readIntoRequests.forEach(a=>{a._closeSteps(void 0)}),r._readIntoRequests=new v),H(e._readableStreamController[ct](t),ot)}function we(e){e._state="closed";const t=e._reader;void 0!==t&&(Gt(t),D(t)&&(t._readRequests.forEach(r=>{r._closeSteps()}),t._readRequests=new v))}function Vr(e,t){e._state="errored",e._storedError=t;const r=e._reader;void 0!==r&&(ft(r,t),D(r)?(r._readRequests.forEach(n=>{n._errorSteps(t)}),r._readRequests=new v):(r._readIntoRequests.forEach(n=>{n._errorSteps(t)}),r._readIntoRequests=new v))}function x(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function Gr(e,t){j(e,t);const r=e?.highWaterMark;return ht(r,"highWaterMark","QueuingStrategyInit"),{highWaterMark:mt(r)}}Object.defineProperties(M.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof f.toStringTag&&Object.defineProperty(M.prototype,f.toStringTag,{value:"ReadableStream",configurable:!0}),"symbol"==typeof f.asyncIterator&&Object.defineProperty(M.prototype,f.asyncIterator,{value:M.prototype.values,writable:!0,configurable:!0});const Zr=e=>e.byteLength;Object.defineProperty(Zr,"name",{value:"size",configurable:!0});class Ze{constructor(t){I(t,1,"ByteLengthQueuingStrategy"),t=Gr(t,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=t.highWaterMark}get highWaterMark(){if(!Kr(this))throw Xr("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!Kr(this))throw Xr("size");return Zr}}function Xr(e){return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`)}function Kr(e){return!(!w(e)||!Object.prototype.hasOwnProperty.call(e,"_byteLengthQueuingStrategyHighWaterMark"))&&e instanceof Ze}Object.defineProperties(Ze.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof f.toStringTag&&Object.defineProperty(Ze.prototype,f.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});const Jr=()=>1;Object.defineProperty(Jr,"name",{value:"size",configurable:!0});class Xe{constructor(t){I(t,1,"CountQueuingStrategy"),t=Gr(t,"First parameter"),this._countQueuingStrategyHighWaterMark=t.highWaterMark}get highWaterMark(){if(!en(this))throw xr("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!en(this))throw xr("size");return Jr}}function xr(e){return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`)}function en(e){return!(!w(e)||!Object.prototype.hasOwnProperty.call(e,"_countQueuingStrategyHighWaterMark"))&&e instanceof Xe}function va(e,t,r){return W(e,r),n=>V(e,t,[n])}function Wa(e,t,r){return W(e,r),n=>ve(e,t,[n])}function Ea(e,t,r){return W(e,r),(n,a)=>V(e,t,[n,a])}Object.defineProperties(Xe.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof f.toStringTag&&Object.defineProperty(Xe.prototype,f.toStringTag,{value:"CountQueuingStrategy",configurable:!0});class Ke{constructor(t={},r={},n={}){void 0===t&&(t=null);const a=De(r,"Second parameter"),o=De(n,"Third parameter"),i=function Ta(e,t){j(e,t);const r=e?.flush,n=e?.readableType,a=e?.start,o=e?.transform,i=e?.writableType;return{flush:void 0===r?void 0:va(r,e,`${t} has member 'flush' that`),readableType:n,start:void 0===a?void 0:Wa(a,e,`${t} has member 'start' that`),transform:void 0===o?void 0:Ea(o,e,`${t} has member 'transform' that`),writableType:i}}(t,"First parameter");if(void 0!==i.readableType)throw new RangeError("Invalid readableType specified");if(void 0!==i.writableType)throw new RangeError("Invalid writableType specified");const s=_e(o,0),u=Ie(o),c=_e(a,1),p=Ie(a);let m;(function qa(e,t,r,n,a,o){function i(){return t}e._writable=function Fn(e,t,r,n,a=1,o=(()=>1)){const i=Object.create(pe.prototype);return Wr(i),zr(i,Object.create(oe.prototype),e,t,r,n,a,o),i}(i,function s(S){return function za(e,t){const r=e._transformStreamController;return e._backpressure?H(e._backpressureChangePromise,()=>{const a=e._writable;if("erroring"===a._state)throw a._storedError;return an(r,t)}):an(r,t)}(e,S)},function c(){return function Ia(e){const t=e._readable,r=e._transformStreamController,n=r._flushAlgorithm();return rn(r),H(n,()=>{if("errored"===t._state)throw t._storedError;Re(t._readableStreamController)},a=>{throw Je(e,a),t._storedError})}(e)},function u(S){return function ja(e,t){return Je(e,t),b(void 0)}(e,S)},r,n),e._readable=Lt(i,function p(){return function Da(e){return et(e,!1),e._backpressureChangePromise}(e)},function m(S){return xe(e,S),b(void 0)},a,o),e._backpressure=void 0,e._backpressureChangePromise=void 0,e._backpressureChangePromise_resolve=void 0,et(e,!0),e._transformStreamController=void 0})(this,R(N=>{m=N}),c,p,s,u),function ka(e,t){const r=Object.create(Ce.prototype);let n=o=>{try{return nn(r,o),b(void 0)}catch(i){return l(i)}},a=()=>b(void 0);void 0!==t.transform&&(n=o=>t.transform(o,r)),void 0!==t.flush&&(a=()=>t.flush(r)),function Aa(e,t,r,n){t._controlledTransformStream=e,e._transformStreamController=t,t._transformAlgorithm=r,t._flushAlgorithm=n}(e,r,n,a)}(this,i),m(void 0!==i.start?i.start(this._transformStreamController):void 0)}get readable(){if(!tn(this))throw on("readable");return this._readable}get writable(){if(!tn(this))throw on("writable");return this._writable}}function tn(e){return!(!w(e)||!Object.prototype.hasOwnProperty.call(e,"_transformStreamController"))&&e instanceof Ke}function Je(e,t){L(e._readable._readableStreamController,t),xe(e,t)}function xe(e,t){rn(e._transformStreamController),Bt(e._writable._writableStreamController,t),e._backpressure&&et(e,!1)}function et(e,t){void 0!==e._backpressureChangePromise&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=R(r=>{e._backpressureChangePromise_resolve=r}),e._backpressure=t}Object.defineProperties(Ke.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),"symbol"==typeof f.toStringTag&&Object.defineProperty(Ke.prototype,f.toStringTag,{value:"TransformStream",configurable:!0});class Ce{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!tt(this))throw rt("desiredSize");return Ft(this._controlledTransformStream._readable._readableStreamController)}enqueue(t){if(!tt(this))throw rt("enqueue");nn(this,t)}error(t){if(!tt(this))throw rt("error");!function Ba(e,t){Je(e._controlledTransformStream,t)}(this,t)}terminate(){if(!tt(this))throw rt("terminate");!function Oa(e){const t=e._controlledTransformStream;Re(t._readable._readableStreamController);xe(t,new TypeError("TransformStream terminated"))}(this)}}function tt(e){return!(!w(e)||!Object.prototype.hasOwnProperty.call(e,"_controlledTransformStream"))&&e instanceof Ce}function rn(e){e._transformAlgorithm=void 0,e._flushAlgorithm=void 0}function nn(e,t){const r=e._controlledTransformStream,n=r._readable._readableStreamController;if(!se(n))throw new TypeError("Readable side is not in a state that permits enqueue");try{Ve(n,t)}catch(o){throw xe(r,o),r._readable._storedError}(function da(e){return!Nr(e)})(n)!==r._backpressure&&et(r,!0)}function an(e,t){return H(e._transformAlgorithm(t),void 0,n=>{throw Je(e._controlledTransformStream,n),n})}function rt(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function on(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}Object.defineProperties(Ce.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof f.toStringTag&&Object.defineProperty(Ce.prototype,f.toStringTag,{value:"TransformStreamDefaultController",configurable:!0})}}]);